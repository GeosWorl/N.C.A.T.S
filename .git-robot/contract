// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// @title NellCarpoolFunding - Funding contract for Nell's Carpool And Transportation Services
/// @notice Accepts Ether, allows owner-controlled withdrawals, and can safely send ERC20 tokens
/// @dev Implements advanced security with active honeypot, time-lock, emergency stop, and non-transferable ownership
/// @dev Deployer (representing Cory K Washington) is the permanent owner

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract NellCarpoolFunding is ReentrancyGuard {
    using SafeERC20 for IERC20;
    using Address for address payable;

    address public immutable owner;
    address public depositAddress;
    bool public paused;
    bool public emergencyStopped;

    uint256 public dailyEtherLimit;
    uint256 public dailyTokenLimit;
    uint256 public constant TIME_LOCK_DELAY = 2430000000; // ~77 years
    uint256 public lastWithdrawalTimestamp;

    mapping(address => uint256) public honeypotCooldown;

    event Deposit(address indexed sender, uint256 amount);
    event Withdrawal(address indexed recipient, uint256 amount);
    event TokensSent(address indexed token, address indexed recipient, uint256 amount);
    event ActionQueued(bytes32 actionId, uint256 unlockTime);
    event ActionExecuted(bytes32 actionId);
    event SuspiciousActivity(address indexed caller);
    event Trapped(address indexed caller);
    event Paused();
    event Unpaused();
    event EmergencyStopActivated();
    event EmergencyStopDeactivated();
    event WithdrawalLimitsUpdated(uint256 etherPerDay, uint256 tokensPerDay);
    event DepositAddressUpdated(address newDepositAddress);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    modifier notPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    modifier notEmergencyStopped() {
        require(!emergencyStopped, "Emergency stop activated");
        _;
    }

    constructor(address _depositAddress, uint256 _initialEtherLimit, uint256 _initialTokenLimit) payable {
        require(msg.value >= 100 ether, "Initial deposit must be at least 100 ETH");
        require(_depositAddress != address(0), "Invalid deposit address");

        owner = msg.sender;
        depositAddress = _depositAddress;
        dailyEtherLimit = _initialEtherLimit;
        dailyTokenLimit = _initialTokenLimit;

        payable(depositAddress).sendValue(msg.value);
    }

    receive() external payable {
        emit Deposit(msg.sender, msg.value);
        payable(depositAddress).sendValue(msg.value);
    }

    fallback() external payable {
        honeypotCooldown[msg.sender] = block.timestamp + 1 hours;
        emit SuspiciousActivity(msg.sender);
        emit Trapped(msg.sender);
    }

    function deposit() external payable notPaused notEmergencyStopped {
        emit Deposit(msg.sender, msg.value);
        payable(depositAddress).sendValue(msg.value);
    }

    function withdraw(uint256 amount) external onlyOwner notPaused notEmergencyStopped nonReentrant {
        require(amount <= dailyEtherLimit, "Exceeds daily Ether limit");
        require(block.timestamp >= lastWithdrawalTimestamp + 1 days, "Daily limit cooldown active");

        lastWithdrawalTimestamp = block.timestamp;
        payable(owner).sendValue(amount);
        emit Withdrawal(owner, amount);
    }

    function executeLargeWithdrawal(uint256 amount) external onlyOwner notPaused notEmergencyStopped nonReentrant {
        require(block.timestamp >= TIME_LOCK_DELAY, "Time-lock active");
        payable(owner).sendValue(amount);
        emit ActionExecuted(keccak256(abi.encodePacked("LargeWithdrawal", amount)));
    }

    function sendTokens(IERC20 token, address recipient, uint256 amount) external onlyOwner notPaused notEmergencyStopped nonReentrant {
        require(amount <= dailyTokenLimit, "Exceeds daily token limit");
        token.safeTransfer(recipient, amount);
        emit TokensSent(address(token), recipient, amount);
    }

    function pause() external onlyOwner {
        paused = true;
        emit Paused();
    }

    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused();
    }

    function activateEmergencyStop() external onlyOwner {
        emergencyStopped = true;
        emit EmergencyStopActivated();
    }

    function deactivateEmergencyStop() external onlyOwner {
        emergencyStopped = false;
        emit EmergencyStopDeactivated();
    }

    function updateWithdrawalLimits(uint256 etherPerDay, uint256 tokensPerDay) external onlyOwner {
        dailyEtherLimit = etherPerDay;
        dailyTokenLimit = tokensPerDay;
        emit WithdrawalLimitsUpdated(etherPerDay, tokensPerDay);
    }

    function updateDepositAddress(address newDepositAddress) external onlyOwner {
        require(newDepositAddress != address(0), "Invalid deposit address");
        depositAddress = newDepositAddress;
        emit DepositAddressUpdated(newDepositAddress);
    }
}